{"ast":null,"code":"var _jsxFileName = \"/Users/amer_/Desktop/Plugin Development Environment/Plugin Development/.obsidian/plugins/Survey Plugin/QuantumComputing/double-slit-experiment/src/WaveCanvas.js\",\n  _s = $RefreshSig$();\n// WaveCanvas.js\n\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function wavelengthToColor(wavelength, brightness) {\n  var R, G, B, alpha;\n  if (wavelength >= 380 && wavelength < 440) {\n    R = -(wavelength - 440) / (440 - 380);\n    G = 0.0;\n    B = 1.0;\n  } else if (wavelength >= 440 && wavelength < 490) {\n    R = 0.0;\n    G = (wavelength - 440) / (490 - 440);\n    B = 1.0;\n  } else if (wavelength >= 490 && wavelength < 510) {\n    R = 0.0;\n    G = 1.0;\n    B = -(wavelength - 510) / (510 - 490);\n  } else if (wavelength >= 510 && wavelength < 580) {\n    R = (wavelength - 510) / (580 - 510);\n    G = 1.0;\n    B = 0.0;\n  } else if (wavelength >= 580 && wavelength < 645) {\n    R = 1.0;\n    G = -(wavelength - 645) / (645 - 580);\n    B = 0.0;\n  } else if (wavelength >= 645 && wavelength <= 750) {\n    R = 1.0;\n    G = 0.0;\n    B = 0.0;\n  } else {\n    R = 0.0;\n    G = 0.0;\n    B = 0.0; // outside the visible spectrum\n  }\n\n  // Increase intensity closer to the vision limits\n  if (wavelength > 700) {\n    alpha = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);\n  } else if (wavelength < 420) {\n    alpha = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);\n  } else {\n    alpha = 1.0;\n  }\n  R = Math.round(R * alpha * 255);\n  G = Math.round(G * alpha * 255);\n  B = Math.round(B * alpha * 255);\n  return `rgb(${brightness * R}, ${brightness * G}, ${brightness * B})`;\n}\n\n// Example usage:\nvar color = wavelengthToColor(500); // A wavelength of 500nm\nconsole.log(color); // Outputs: rgb(0, 255, 0)\n\nconst WaveCanvas = ({\n  points,\n  intensity,\n  wavelength\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n    ctx.clearRect(0, 0, width, height); // Clear the canvas before drawing\n    // Draw vertical lines based on the intensity array\n    function mapIntensity(intensity, maxIntensity) {\n      // we're just going to make it modify the tolerance on the data\n      const ceilingCover = .05 * maxIntensity;\n      let newIntensities = intensity.map(intensity => intensity / ceilingCover);\n      // if a value is greater than 1, make it 1\n      // if a value is less than 0, make it 0\n      // newIntensities = newIntensities.map((intensity) =>\n      //   intensity > 1 ? 1 : intensity\n      // );\n\n      return newIntensities;\n    }\n    points.forEach((point, index) => {\n      const x = index / points.length * width;\n      // get the maximum value of the intensity array\n      const maxIntensity = Math.max(...intensity);\n      // divide all in the intensity array by the max intensity\n\n      intensity = mapIntensity(intensity, maxIntensity);\n\n      // scale the intensity array to 0-255\n      const brightness = intensity[index]; // Scale brightness to 0-255\n      // then given some brightness, we take some RGB\n      const RGB = wavelengthToColor(wavelength, brightness);\n      // const color = `rgb(${brightness*RGB[0]},${brightness*RGB[1]},${brightness*RGB[2]})`;\n      ctx.strokeStyle = RGB;\n      ctx.beginPath();\n      ctx.moveTo(x, 0); // Start at the top of the canvas\n      ctx.lineTo(x, height); // Draw to the bottom of the canvas\n      ctx.stroke(); // Execute the drawing command\n    });\n  }, [points, intensity]); // Redraw when points or intensity arrays change\n\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 1000,\n    height: 200,\n    style: {\n      backgroundColor: '#fff'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 105,\n    columnNumber: 10\n  }, this);\n};\n_s(WaveCanvas, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = WaveCanvas;\nexport default WaveCanvas;\nvar _c;\n$RefreshReg$(_c, \"WaveCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","wavelengthToColor","wavelength","brightness","R","G","B","alpha","Math","round","color","console","log","WaveCanvas","points","intensity","_s","canvasRef","canvas","current","ctx","getContext","width","height","clearRect","mapIntensity","maxIntensity","ceilingCover","newIntensities","map","forEach","point","index","x","length","max","RGB","strokeStyle","beginPath","moveTo","lineTo","stroke","ref","style","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/amer_/Desktop/Plugin Development Environment/Plugin Development/.obsidian/plugins/Survey Plugin/QuantumComputing/double-slit-experiment/src/WaveCanvas.js"],"sourcesContent":["// WaveCanvas.js\n\nimport React, { useRef, useEffect } from 'react';\nexport function wavelengthToColor(wavelength,brightness) {\n    var R, G, B, alpha;\n\n    if (wavelength >= 380 && wavelength < 440) {\n        R = -(wavelength - 440) / (440 - 380);\n        G = 0.0;\n        B = 1.0;\n    } else if (wavelength >= 440 && wavelength < 490) {\n        R = 0.0;\n        G = (wavelength - 440) / (490 - 440);\n        B = 1.0;\n    } else if (wavelength >= 490 && wavelength < 510) {\n        R = 0.0;\n        G = 1.0;\n        B = -(wavelength - 510) / (510 - 490);\n    } else if (wavelength >= 510 && wavelength < 580) {\n        R = (wavelength - 510) / (580 - 510);\n        G = 1.0;\n        B = 0.0;\n    } else if (wavelength >= 580 && wavelength < 645) {\n        R = 1.0;\n        G = -(wavelength - 645) / (645 - 580);\n        B = 0.0;\n    } else if (wavelength >= 645 && wavelength <= 750) {\n        R = 1.0;\n        G = 0.0;\n        B = 0.0;\n    } else {\n        R = 0.0;\n        G = 0.0;\n        B = 0.0; // outside the visible spectrum\n    }\n\n    // Increase intensity closer to the vision limits\n    if (wavelength > 700) {\n        alpha = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);\n    } else if (wavelength < 420) {\n        alpha = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);\n    } else {\n        alpha = 1.0;\n    }\n\n    R = Math.round(R * alpha * 255);\n    G = Math.round(G * alpha * 255);\n    B = Math.round(B * alpha * 255);\n\n    return `rgb(${brightness*R}, ${brightness*G}, ${brightness*B})`;\n}\n\n\n// Example usage:\nvar color = wavelengthToColor(500); // A wavelength of 500nm\nconsole.log(color); // Outputs: rgb(0, 255, 0)\n\nconst WaveCanvas = ({ points, intensity,wavelength }) => {\n  const canvasRef = useRef(null);\n\n  useEffect(() => { \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const width = canvas.width;\n    const height = canvas.height;\n\n    ctx.clearRect(0, 0, width, height); // Clear the canvas before drawing\n    // Draw vertical lines based on the intensity array\n    function mapIntensity(intensity,maxIntensity){\n      // we're just going to make it modify the tolerance on the data\n      const ceilingCover = .05*maxIntensity;\n      let newIntensities = intensity.map((intensity) =>\n        intensity/ceilingCover\n      );\n      // if a value is greater than 1, make it 1\n      // if a value is less than 0, make it 0\n      // newIntensities = newIntensities.map((intensity) =>\n      //   intensity > 1 ? 1 : intensity\n      // );\n\n         \n      return newIntensities;\n    }\n    points.forEach((point, index) => {\n      const x = (index / points.length) * width;\n      // get the maximum value of the intensity array\n      const maxIntensity = Math.max(...intensity);\n      // divide all in the intensity array by the max intensity\n      \n      intensity =  mapIntensity(intensity,maxIntensity);\n\n      // scale the intensity array to 0-255\n      const brightness = intensity[index];  // Scale brightness to 0-255\n      // then given some brightness, we take some RGB\n      const RGB = wavelengthToColor(wavelength, brightness)\n      // const color = `rgb(${brightness*RGB[0]},${brightness*RGB[1]},${brightness*RGB[2]})`;\n      ctx.strokeStyle = RGB;\n      ctx.beginPath();\n      ctx.moveTo(x, 0);  // Start at the top of the canvas\n      ctx.lineTo(x, height);  // Draw to the bottom of the canvas\n      ctx.stroke();  // Execute the drawing command\n    });\n  }, [points, intensity]);  // Redraw when points or intensity arrays change\n\n  return <canvas ref={canvasRef} width={1000} height={200} style={{ backgroundColor: '#fff' }} />;\n};\n\nexport default WaveCanvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}