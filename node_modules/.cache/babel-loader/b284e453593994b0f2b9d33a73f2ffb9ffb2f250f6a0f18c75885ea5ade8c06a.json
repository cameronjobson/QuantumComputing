{"ast":null,"code":"var _jsxFileName = \"/Users/amer_/Documents/GitHub/QuantumComputingPersonal/src/ObserverEffectCanvas.js\",\n  _s = $RefreshSig$();\n// ObserverEffectCanvas.js\n\nimport React, { useRef, useEffect } from 'react';\nimport { wavelengthToColor } from './WaveCanvas';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ObserverEffectCanvas = ({\n  points,\n  intensity,\n  measure,\n  wavelength\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const dotRadius = 2;\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const width = canvas.width;\n    const height = canvas.height;\n    ctx.clearRect(0, 0, width, height);\n    if (measure) {\n      // If measurement is true, collapse the wave function (no interference pattern)\n      drawPhotons(ctx, width, height, points, intensity);\n    }\n  }, [points, intensity, measure]);\n\n  // function drawPhotons(ctx, width, height, points, intensity) {\n\n  //   const scale = height / Math.max(...intensity);\n  //   const maxIntensity = Math.max(...intensity);\n  //   ctx.fillStyle = wavelengthToColor(wavelength, 1);\n  //   points.forEach((point, index) => {\n  //     const x = (index / points.length) * width;\n  //     const y = height - intensity[index] * scale; // Invert y-axis for canvas\n  //     const brightness = intensity[index] / maxIntensity; // Normalize brightness\n  //     const dotSize = dotRadius;\n  //     ctx.beginPath();\n  //     ctx.arc(x, y, dotSize, 0, 2 * Math.PI);\n  //     ctx.fill();\n  //   });\n  // }\n  function drawPhotons(ctx, width, height, points, intensity) {\n    const scale = height / Math.max(...intensity);\n    const maxIntensity = Math.max(...intensity);\n    ctx.strokeStyle = wavelengthToColor(wavelength, 1);\n    ctx.lineWidth = 2; // Adjust line width as needed\n    ctx.beginPath();\n    points.forEach((point, index) => {\n      const x = index / points.length * width;\n      const y = height - intensity[index] * scale; // Invert y-axis for canvas\n      const brightness = intensity[index] / maxIntensity; // Normalize brightness\n      if (index === 0) {\n        ctx.moveTo(x, y); // Move to the first point\n      } else {\n        ctx.lineTo(x, y); // Draw line to the current point from the previous one\n      }\n    });\n    ctx.stroke(); // Stroke the path to draw the lines\n  }\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 1000,\n    height: 200,\n    style: {\n      backgroundColor: \"#fff\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 62,\n    columnNumber: 5\n  }, this);\n};\n_s(ObserverEffectCanvas, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = ObserverEffectCanvas;\nexport default ObserverEffectCanvas;\nvar _c;\n$RefreshReg$(_c, \"ObserverEffectCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","wavelengthToColor","jsxDEV","_jsxDEV","ObserverEffectCanvas","points","intensity","measure","wavelength","_s","canvasRef","dotRadius","canvas","current","ctx","getContext","width","height","clearRect","drawPhotons","scale","Math","max","maxIntensity","strokeStyle","lineWidth","beginPath","forEach","point","index","x","length","y","brightness","moveTo","lineTo","stroke","ref","style","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/amer_/Documents/GitHub/QuantumComputingPersonal/src/ObserverEffectCanvas.js"],"sourcesContent":["// ObserverEffectCanvas.js\n\nimport React, { useRef, useEffect } from 'react';\nimport { wavelengthToColor } from './WaveCanvas';\nconst ObserverEffectCanvas = ({\n  points,\n  intensity,\n  measure,\n  wavelength,\n}) => {\n  const canvasRef = useRef(null);\n  const dotRadius = 2;\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    const width = canvas.width;\n    const height = canvas.height;\n    ctx.clearRect(0, 0, width, height);\n\n    if (measure) {\n      // If measurement is true, collapse the wave function (no interference pattern)\n      drawPhotons(ctx, width, height, points, intensity);\n    }\n  }, [points, intensity, measure]);\n\n  // function drawPhotons(ctx, width, height, points, intensity) {\n    \n  //   const scale = height / Math.max(...intensity);\n  //   const maxIntensity = Math.max(...intensity);\n  //   ctx.fillStyle = wavelengthToColor(wavelength, 1);\n  //   points.forEach((point, index) => {\n  //     const x = (index / points.length) * width;\n  //     const y = height - intensity[index] * scale; // Invert y-axis for canvas\n  //     const brightness = intensity[index] / maxIntensity; // Normalize brightness\n  //     const dotSize = dotRadius;\n  //     ctx.beginPath();\n  //     ctx.arc(x, y, dotSize, 0, 2 * Math.PI);\n  //     ctx.fill();\n  //   });\n  // }\n  function drawPhotons(ctx, width, height, points, intensity) {\n    const scale = height / Math.max(...intensity);\n    const maxIntensity = Math.max(...intensity);\n    ctx.strokeStyle = wavelengthToColor(wavelength, 1);\n    ctx.lineWidth = 2; // Adjust line width as needed\n    ctx.beginPath();\n    points.forEach((point, index) => {\n      const x = (index / points.length) * width;\n      const y = height - intensity[index] * scale; // Invert y-axis for canvas\n      const brightness = intensity[index] / maxIntensity; // Normalize brightness\n      if (index === 0) {\n        ctx.moveTo(x, y); // Move to the first point\n      } else {\n        ctx.lineTo(x, y); // Draw line to the current point from the previous one\n      }\n    });\n    ctx.stroke(); // Stroke the path to draw the lines\n  }\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={1000}\n      height={200}\n      style={{ backgroundColor: \"#fff\" }}\n    />\n  );\n};\n\nexport default ObserverEffectCanvas;\n"],"mappings":";;AAAA;;AAEA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,SAAS,QAAQ,OAAO;AAChD,SAASC,iBAAiB,QAAQ,cAAc;AAAC,SAAAC,MAAA,IAAAC,OAAA;AACjD,MAAMC,oBAAoB,GAAGA,CAAC;EAC5BC,MAAM;EACNC,SAAS;EACTC,OAAO;EACPC;AACF,CAAC,KAAK;EAAAC,EAAA;EACJ,MAAMC,SAAS,GAAGX,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMY,SAAS,GAAG,CAAC;EAEnBX,SAAS,CAAC,MAAM;IACd,MAAMY,MAAM,GAAGF,SAAS,CAACG,OAAO;IAChC,MAAMC,GAAG,GAAGF,MAAM,CAACG,UAAU,CAAC,IAAI,CAAC;IACnC,MAAMC,KAAK,GAAGJ,MAAM,CAACI,KAAK;IAC1B,MAAMC,MAAM,GAAGL,MAAM,CAACK,MAAM;IAC5BH,GAAG,CAACI,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEF,KAAK,EAAEC,MAAM,CAAC;IAElC,IAAIV,OAAO,EAAE;MACX;MACAY,WAAW,CAACL,GAAG,EAAEE,KAAK,EAAEC,MAAM,EAAEZ,MAAM,EAAEC,SAAS,CAAC;IACpD;EACF,CAAC,EAAE,CAACD,MAAM,EAAEC,SAAS,EAAEC,OAAO,CAAC,CAAC;;EAEhC;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAASY,WAAWA,CAACL,GAAG,EAAEE,KAAK,EAAEC,MAAM,EAAEZ,MAAM,EAAEC,SAAS,EAAE;IAC1D,MAAMc,KAAK,GAAGH,MAAM,GAAGI,IAAI,CAACC,GAAG,CAAC,GAAGhB,SAAS,CAAC;IAC7C,MAAMiB,YAAY,GAAGF,IAAI,CAACC,GAAG,CAAC,GAAGhB,SAAS,CAAC;IAC3CQ,GAAG,CAACU,WAAW,GAAGvB,iBAAiB,CAACO,UAAU,EAAE,CAAC,CAAC;IAClDM,GAAG,CAACW,SAAS,GAAG,CAAC,CAAC,CAAC;IACnBX,GAAG,CAACY,SAAS,CAAC,CAAC;IACfrB,MAAM,CAACsB,OAAO,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK;MAC/B,MAAMC,CAAC,GAAID,KAAK,GAAGxB,MAAM,CAAC0B,MAAM,GAAIf,KAAK;MACzC,MAAMgB,CAAC,GAAGf,MAAM,GAAGX,SAAS,CAACuB,KAAK,CAAC,GAAGT,KAAK,CAAC,CAAC;MAC7C,MAAMa,UAAU,GAAG3B,SAAS,CAACuB,KAAK,CAAC,GAAGN,YAAY,CAAC,CAAC;MACpD,IAAIM,KAAK,KAAK,CAAC,EAAE;QACff,GAAG,CAACoB,MAAM,CAACJ,CAAC,EAAEE,CAAC,CAAC,CAAC,CAAC;MACpB,CAAC,MAAM;QACLlB,GAAG,CAACqB,MAAM,CAACL,CAAC,EAAEE,CAAC,CAAC,CAAC,CAAC;MACpB;IACF,CAAC,CAAC;IACFlB,GAAG,CAACsB,MAAM,CAAC,CAAC,CAAC,CAAC;EAChB;EAEA,oBACEjC,OAAA;IACEkC,GAAG,EAAE3B,SAAU;IACfM,KAAK,EAAE,IAAK;IACZC,MAAM,EAAE,GAAI;IACZqB,KAAK,EAAE;MAAEC,eAAe,EAAE;IAAO;EAAE;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACpC,CAAC;AAEN,CAAC;AAAClC,EAAA,CAhEIL,oBAAoB;AAAAwC,EAAA,GAApBxC,oBAAoB;AAkE1B,eAAeA,oBAAoB;AAAC,IAAAwC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}